---
title: "Concurrency"
date: 2025-03-04T21:09:21+08:00
draft: true
---

为什么出发

程序抽象进程，由os调度执行。所谓调度是由于必须让许多进程同时在有限的cpu上执行即cpu virtialization。操作系统的调度机制通过中断实现的（trap vs interrupt）。

中断发生后，os调度决定是否切换进程，是则进行context switch, 由硬件支持，os内核模式完成。最终用户模式执行新进程。

CPU存在硬件缓存（本地副本），利用时间和空间的 cache locality 以提升程序性能。
多cpu调度时，每个cpu缓存独立，相当于同一块内存在时空上的不同副本，这种分布式的数据读写一定存在一致性问题，如读旧值、丢失更新，解法通常包括

硬件提供了机制，检测内存数据更新使本地副本失效。这只解决了一部分问题，即内存->缓存刷新，缓存之间仍具有不可见性。

线程是程序调度的基本单位（或者说是OS需要负责调度的最小单位），创建线程使进程具有利用多cpu核心的能力，共享数据以高效地在线程间互相通信。
线程安全问题依然在于不可控的调度，如这个广泛引用的例子：a=a+1，两个线程并发对同一个值累加1万次，结果大概率不是20000。由于这个语句不是原子操作（查看其汇编码可知），随时可能被中断，线程切换时保存或恢复各自专用寄存器的值，切换回时由于寄存器中的源值内存值可能已经变更。

Concurrency 不止发生在多核系统，可以在单核运行多线程程序，这种程序亦会发生待解决的同步问题，因为中断 上下文切换依然存在。

Dijkstra 命名了上述的现象为 race condition, 涉及的代码段为临界区。只要程序依赖不可控的顺序，就会发生race。

我们希望避免临界区的race, 或者关闭中断，或者使临界区为原子操作。

编程语言中常见锁结构即是第二个思路的实现。锁通常由硬件以及软件(OS)提供支持。如由硬件提供的原子指令可用于实现自旋锁。由于自旋性能问题，OS实现park和unpark结合自旋实现高性能锁。

注：锁隐含了memory barriers 以实现读和写的可见性。

除了原子性问题，并发程序还会遇到顺序问题，以及死锁。

Java memory model

因为cache 使共享变量具有多个副本，而reordering进一步扰乱了这种可见性,多线程程序中需要明确对变量的更新是否能被其他线程读到。因此memory model 定义了必要且充分的visibility条件，guarantee。jmm提供了跨不同架构的同步语义。

mm包含了一些机制和内置约束.

happen-before 定义了这些基础顺序约束
1 program order, 一切顺序的基础。
2 lock unlock order
3 thread start order
4 volatile order
5 join order


互斥（锁）只是同步的一方面，还需要解决内存可见性，进出临界区隐含是缓存和内存一致。同时由于指令重排序多线程时违反程序期望的可见性顺序造成问题，如常见的new 对象构造，new关键字编译为三条基础指令，重排序导致线程在对象未初始化即被访问到。

JMM 提供跨硬件和OS的一致性语义，描述了多线程读写共享变量的行为，确保他们在所有架构上正确。

all is about happen-before定义了JMM保证的


todo

kernal and user space

进程切换 vs 线程切换 vs 协程切换

切换状态：寄存器和缓存

trap and interrupt

- 操作系统导论 雷姆兹•H.阿帕希杜塞尔和安德莉亚•C.阿帕希杜塞尔著
- http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html